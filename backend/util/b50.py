# TODO: Implement b50 table generation functions
from pathlib import Path
from typing import List
import json
import csv
import io
import os

from PIL import Image, ImageDraw, ImageFont, ImageOps, ImageFilter, ImageEnhance
from pydantic import ValidationError

from .. import config as backend_config
from ..model.schemas import PlayRecordInfo, SongLevelInfo, PlayRecordCreate, SongLevelCsv
from ..service import song as song_service


def image_to_byte_array(image: Image) -> bytes:
    imgByteArr = io.BytesIO()
    image.save(imgByteArr, format="png")
    imgByteArr = imgByteArr.getvalue()
    return imgByteArr


def draw_single_text(draw: ImageDraw, font: ImageFont, config, content):
    df = font.font_variant(size=config['font_size'])
    draw.multiline_text((config['x'], config['y']),
                        text=content,
                        font=df,
                        fill=tuple(config['text_rgba']))


def draw_single_text_border(draw: ImageDraw, font: ImageFont, config, content, color=(0, 0, 0, 0)):
    df = font.font_variant(size=config['font_size'])
    draw.multiline_text((config['x'] + 1, config['y']),
                        text=content, font=df, fill=color)
    draw.multiline_text((config['x'] - 1, config['y']),
                        text=content, font=df, fill=color)
    draw.multiline_text((config['x'], config['y'] + 1),
                        text=content, font=df, fill=color)
    draw.multiline_text((config['x'], config['y'] - 1),
                        text=content, font=df, fill=color)


async def generate_b50_img(play_records: list[PlayRecordInfo], nickname, character: str = 'Para_Young_Awaken',
                           credential_info: str = "Generated by PRP-API",
                           config_path: str = "resources/image/template/b50_ruins_template_thin.json",
                           height: int = 1080):
    b35, b15 = [], []
    b35_ra, b15_ra = 0, 0
    for record in play_records:
        if record.song_level.b15:
            b15_ra += record.rating
            b15.append(record)
        else:
            b35_ra += record.rating
            b35.append(record)

    b50_ra = (b35_ra + b15_ra) / 5000
    b35_ra /= 3500
    b15_ra /= 1500
    username = nickname

    # Generate Image process
    with open(config_path, 'r', encoding='utf-8') as f:
        config = json.load(f)
    template = Image.open(config['file']).convert("RGBA")
    font = ImageFont.truetype(config['font'], encoding='unic')
    title_font = ImageFont.truetype(config['title_font'], encoding='unic')
    score_font = ImageFont.truetype(config['score_font'], encoding='unic')
    draw = ImageDraw.Draw(template)

    # Draw credential
    draw_single_text(draw, font, config['generated_by'], credential_info)

    # Draw username
    draw_single_text(draw, font, config['username'], username)

    # Draw rating
    draw_single_text(draw, font, config['rating'], "%.4f" % b50_ra)
    draw_single_text(draw, font, config['b35_rating'], "%.4f" % b35_ra)
    draw_single_text(draw, font, config['b15_rating'], "%.4f" % b15_ra)

    # Draw character:
    character_img = Image.open(backend_config.CHARACTERS[character]).convert('RGBA')
    character_img = ImageOps.contain(character_img, (config['character']['width'], config['character']['height']))
    template.alpha_composite(character_img, (config['character']['x'], config['character']['y']))

    # Draw single
    x_offset, y_offset = config['b35_offset']['x'], config['b35_offset']['y']
    x_padding, y_padding = config['padding']['x'], config['padding']['y']
    for i, record in enumerate(b35):
        single = generate_single(config, font, title_font, score_font, record, i + 1)
        template.alpha_composite(single, (x_offset, y_offset))
        x_offset += config['single']['width'] + x_padding
        if (i + 1) % 5 == 0:
            x_offset = config['b35_offset']['x']
            y_offset += config['single']['height'] + y_padding

    x_offset, y_offset = config['b15_offset']['x'], config['b15_offset']['y']
    for i, record in enumerate(b15):
        single = generate_single(config, font, title_font, score_font, record, i + 1)
        template.alpha_composite(single, (x_offset, y_offset))
        x_offset += config['single']['width'] + x_padding
        if (i + 1) % 5 == 0:
            x_offset = config['b15_offset']['x']
            y_offset += config['single']['height'] + y_padding

    template = template.resize((int(template.width / template.height * height), height))
    return template


def generate_single(config, font: ImageFont, title_font: ImageFont, score_font: ImageFont,
                    record: PlayRecordInfo, index: int, radius=3):
    cover_path = backend_config.RESOURCE_COVER_PATH + record.song_level.cover
    if not os.path.exists(cover_path):
        cover_path = backend_config.RESOURCE_COVER_PATH + 'default.png'
    cover = Image.open(cover_path).convert("RGBA")
    cover = ImageOps.fit(cover, (config['single']['width'] - radius * 2, config['single']['height'] - radius * 2))
    single = Image.new("RGBA", (config['single']['width'], config['single']['width']), (0, 0, 0, 0))
    single.paste(cover, (radius, radius))
    single = single.filter(ImageFilter.GaussianBlur(radius=radius))
    enhancer = ImageEnhance.Brightness(single)
    single = enhancer.enhance(0.7)
    single_draw = ImageDraw.Draw(single)
    # Draw single title
    if len(record.song_level.title) > 18:
        record.song_level.title = record.song_level.title[:15] + '...'
    draw_single_text_border(single_draw, title_font, config['single']['title'], record.song_level.title)
    draw_single_text(single_draw, title_font, config['single']['title'], record.song_level.title)
    # Draw index
    index_str = '#' + ('0' if index < 10 else '') + str(index)
    draw_single_text_border(single_draw, font, config['single']['index'], index_str)
    draw_single_text(single_draw, font, config['single']['index'], index_str)
    # Draw single difficulty
    draw_single_text_border(single_draw, font, config['single']['difficulty'],
                            record.song_level.difficulty)
    if record.song_level.difficulty == 'Detected':
        color = config['det_rgba']
    elif record.song_level.difficulty == 'Invaded':
        color = config['ivd_rgba']
    elif record.song_level.difficulty == 'Massive':
        color = config['msv_rgba']
    else:
        color = config['text_rgba']
    df = font.font_variant(size=config['single']['difficulty']['font_size'])
    single_draw.multiline_text((config['single']['difficulty']['x'], config['single']['difficulty']['y']),
                               text=record.song_level.difficulty,
                               fill=tuple(color), font=df)
    # Draw single score
    draw_single_text_border(single_draw, score_font, config['single']['score'], str(record.score))
    draw_single_text(single_draw, score_font, config['single']['score'], str(record.score))
    # Draw single rating
    draw_single_text_border(single_draw, font, config['single']['rating'],
                            "%.1f->%.2f" % (record.song_level.level, record.rating / 100))
    draw_single_text(single_draw, font, config['single']['rating'],
                     "%.1f->%.2f" % (record.song_level.level, record.rating / 100))
    # Paste to template
    return single


def json2csv(play_records: list[PlayRecordInfo]):
    # TODO: json to .csv file
    pass


def get_records_from_csv(filename: str = "default.csv") -> List[PlayRecordCreate]:
    records: List[PlayRecordCreate] = []
    with open(backend_config.UPLOAD_CSV_PATH + filename, 'r', encoding='utf-8-sig') as f:
        reader = csv.DictReader(f)
        for row in reader:
            try:
                record = PlayRecordCreate(**row)
                records.append(record)
            except ValidationError as e:
                pass
    return records


def generate_empty_csv(file_path: Path, song_levels: List[SongLevelInfo]):
    with open(file_path / 'default.csv', 'w', encoding='utf-8-sig', newline="") as f:
        writer = csv.writer(f)
        headers = ['song_level_id', 'title', 'version', 'difficulty', 'level', 'score']
        writer.writerow(headers)
        for level in song_levels:
            writer.writerow([level['song_level_id'],
                             level['title'],
                             level['version'],
                             level['difficulty'],
                             level['level']])
        f.close()
